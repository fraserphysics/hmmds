% Notes on Maximum A posteriori Probabilty (MAP) estimation.

% Copyright 2022 Andrew M. Fraser.
\documentclass[12pt]{article}
\usepackage{amsmath, amsfonts}


\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\INTEGER}{\field{Z}}
\newcommand{\REAL}{\field{R}}
\newcommand{\COMPLEX}{\field{C}}
\newcommand{\id}{\mathbb{I}}
\newcommand{\variance}[1]{\field{V}\left[ #1 \right]}
\newcommand{\normal}[2]{{\cal N}\left(#1,#2 \right)}

\title{Models of the Laser Data}
\author{Andrew M.\ Fraser}

\begin{document}
\maketitle

\section{Introduction}
\label{sec:introduction}

I have tried several techniques for modeling the laser data from Tang
et al.  From that effort I have developed a sequence of steps that
prodeuces models and figures that I will put in the book.  Here I
describe some of the techniques and that sequence.

\section{Steps}
\label{sec:steps}

The \emph{Makefile} documents the procedure.

\subsection{GUI}
\label{sec:gui}

To get a model that approximates the period five data, I wrote the
module \emph{explore.py}.  I ran \emph{python explore.py} and adjusted
the sliders to roughly match the first nine oscillations of the data.
To calculate the initial condition for the displayed trajectory, the
code solves for one of the fixed points of the Lorenz system and does
a spectral decompositon of the linear approximation of the system at
that point.  Then it integrates for an interval $\Delta_t$ (given by a
slider) from a point on the subspace corresponding to the pair of
complex eigenvalues that is $\Delta_x$ (specified by a slider) away
from the fixed point.

Here are the names of the sliders and their effects:
\begin{description}
\item[r] A parameter of the Lorenz system.  The other values are fixed
  at $s=10.0$ and $b=8.0/3$.
\item[delta\_x] Part of the specification of the initial condidtion
  described above.
\item[delta\_t] Part of the specification of the initial condidtion
  described above.
\item[t\_ratio] Ratio of time intervals of the Lorenz system and time
  intervals of the data.
\item[x\_ratio and offset] The data model is $y[t] = x_{\text{ratio}} \cdot
  x[t,0] \cdot x[t,0] + \text{offset}$.
\item[T\_total] A floating point number that specifies the interval to
  simulate.
\end{description}
Once I got a rough match I pressed the button \emph{Write values to
  file} which writes the slider values to the file \emph{explore.txt}.
I've committed \emph{explore.txt} to the git repository.

\subsection{Extended Kalman Filter}
\label{sec:ekf}

The module \emph{optimize\_ekf.py} calls the function
scipy.optimize.minimize with an objective function that implements an
extended Kalman filter.  It searches for the maximum likelihood in an
11 dimesional parameter space.  The parameters include all three
parameters of the Lorenz system, the 3-d initial condition,
observation function parameters and the amplitudes of the state and
observation noise.  The code writes a text file describing the result.
As a starting point, it can read either a parameter file written by
the GUI or a file that it wrote itself.

\section{Particle Filter for Linear Observation of Lorenz}
\label{sec:linear_observation}

The module \emph{optimize\_particle.py} is a variant of
\emph{optimize\_ekf.py} that uses a particle filter rather than an
extended Kalman filter in the objective function.  Also it can
optimize over a smaller paramater space.  Applying it to
powell250.paramters and searching for noise amplitudes yields
\begin{align*}
  \text{state noise: }       0.6331 &\rightarrow 0.2632 \\
  \text{observation noise: } 0.5275 &\rightarrow 0.0964
\end{align*}

\subsection{Init}
\label{sec:init}

\begin{description}
\item[$\Sigma_\epsilon$ observation\_covariance:] 
\item[$O$ observation\_map:] 
\item[$I_y$ info\_y:] $O^T \Sigma_\epsilon^{-1} O$
\item[$\Sigma_\eta$ state\_covariance:] 
\item[$\Sigma_i$ importance\_covariance:] $\Sigma_i = \left(
    \Sigma_\eta^{-1} + I_y \right)^{-1}$
\item[$G_i$ $importance\_gain$:] $G_i = \Sigma_i \cdot O^T \cdot
  \Sigma_\epsilon^{-1} $
\item[$\Phi: X \mapsto X$ Integrate Lorenz for dt:] 
\item[$p(x_{t+1}|x_t)$ transition:] 
\item[$p(y_t|x_t)$ observation:] 
\item[$q(y_{t+1},x_t)$ importance:] $q(x[t+1]|y[t+1], x[t]) =
  p(x[t+1]|y[t+1], x[t])$.  The importance method draws $x[t+1]$
  from the $q$ distribution and returns both $x[t+1]$ and the value
  of $q$.
\end{description}

\subsection{Importance Method}
\label{sec:importance}

The argument $observation\_map$ affects the following attributes of
self: $observation\_map$, $importance\_distribution$,
$importance\_gain$, and $importance\_covariance$.  In turn those
attributes are used in the following methods: $observation$ and
$importance$.  To do particle filtering on the laser data, I need a
new $importance$ method that accounts for the nonlinear
$observation\_map$.

Let me start by describing the importance method for the linear
observation.
\begin{description}
\item[$\mu_{\text{forecast}}$:]  $\phi(x[t])$
\item[$\Delta_{\text{forecast}}$:] $y[t+1] - O \cdot \mu_{\text{forecast}}$
\item[$\mu_{\text{update}}$:]  $\mu_{\text{forecast}} + G_i \cdot
  \Delta_{\text{forecast}}$
\item[$\eta_{t+1}$:] Draw from $importance\_distribution$
\item[$x_{t+1}$:] $\mu_{\text{update}} + \eta[t+1]$
\end{description}
The method returns $x[t+1]$ and $p(\eta[t+1])$ using a distribution
$\normal{\mu_i}{\Sigma_i}$.  Key to calculating $\mu_i$ is the
\emph{importance gain}, $G_i$.

Here are calculations of $\Sigma_i$, $\mu_i$ and $G_i$.  Note for
\begin{equation*}
  p(X[t+1]|y[t+1], x[t]) \propto p(X[t+1]|x[t]) \cdot p(y[t+1]|X[t+1])
\end{equation*}
I can ignore normalization, and focus only on the exponent.
Letting $E$ be -2 times the exponent, I write
\begin{align*}
  E = & \left( X[t+1] - \Phi(x[t]) \right)^T \Sigma_\eta^{-1} \left(
    X[t+1] - \Phi(x[t]) \right) \\ +& \left( y[t+1] - O X[t+1] \right)^T
  \Sigma_\epsilon^{-1} \left( y[t+1] - O X[t+1] \right)
\end{align*}
Using the abbreviations
\begin{align*}
  X &= X[t+1] \\
  \Phi &= \Phi(x[t]) \\
  y &= y[t+1] \\
  \mu_i &= \mu \\
  \Sigma_i &= \Sigma,
\end{align*}
I write
\begin{align}
  \label{eq:AbbrevE}
  E &= \left( X-\Phi \right)^T \Sigma_\eta^{-1} \left( X-\Phi \right) +
  \left( y - OX \right)^T \Sigma_\epsilon^{-1} \left( y - OX \right)
  \\ \nonumber
  &= X^T \Sigma_\eta^{-1} X -2 \Phi^T \Sigma_\eta^{-1} X + \Phi^T
    \Sigma_\eta^{-1} \Phi \\ \nonumber
    &\quad + y^T \Sigma_\eta^{-1} y - 2 y^T \Sigma_\eta^{-1} OX +
      X^TO^T \Sigma_\eta^{-1} OX \\  \nonumber
  &= X^T\left(\Sigma_\eta^{-1} + O^T \Sigma_\epsilon O \right) X - 2
    \left( \Phi^T \Sigma_\eta^{-1} + y^T \Sigma_\epsilon^{-1} O
    \right) X + R
\end{align}
Thus $\Sigma = \left(\Sigma_\eta^{-1} + O^T \Sigma_\epsilon O
\right)^{-1}$ and since
\begin{align*}
  E &= (X-\mu)^T \Sigma^{-1}(X-\mu) \\
    &= X^T \Sigma^{-1} X - 2\mu^T\Sigma^{-1} X + R \\
    &= X^T \Sigma^{-1} X - 2X^T \Sigma^{-1} \mu + R
\end{align*}
I can write
\begin{align*}
  \Sigma^{-1} \mu &= \Sigma_\eta^{-1} \Phi + O^T \Sigma_\epsilon^{-1}
                    y \\
               \mu &= \Sigma\Sigma_\eta^{-1} \Phi + \Sigma O^T
                     \Sigma_\epsilon^{-1} y,
\end{align*}
and since (by multiplying both sides by $\Sigma^{-1}$ one can verify)
\begin{equation*}
  \Sigma \Sigma_\eta^{-1} = \id - \Sigma O^T \Sigma_\eta^{-1} O,
\end{equation*}
I can write
\begin{align*}
  \mu &= \left( \id - \Sigma O^T \Sigma_\eta^{-1} O \right) \Phi +
        \Sigma O^T \Sigma_\epsilon^{-1} y \\
      &= \Phi + \Sigma O^T \Sigma_\epsilon^{-1} (y - O\Phi)
\end{align*}
In summary:
\begin{subequations}
  \label{eq:LinearImportance}
  \begin{align}
    \Sigma_i &= \left( \Sigma_\eta^{-1} + O^T \Sigma_\epsilon^{-1} O
               \right)^{-1} \\
    G_i &= \Sigma_i O^T \Sigma_\epsilon^{-1} \\
    \mu_i &= \Phi(x[t]) + G_i \left(y[t+1] - O \Phi(x[t]) \right)
  \end{align}
\end{subequations}

\section{Particle Filter for Nonlinear Observation of Lorenz with
  Gaussian Observation Noise}
\label{sec:nonlinear}

Here the observation map is a nonlinear function $\psi$.  I want to
use its first order approximation
\begin{align*}
  \psi(X) &\approx \psi(\Phi) + \psi' (X-\Phi) \quad \text{where
            $\psi'$ is evaluated at $\Phi$}\\
  &= \psi(\Phi) - \psi'\Phi + \psi' X
\end{align*}
in a derivation that mimics \eqref{eq:AbbrevE}.  I replace the term
$(y-OX)$ in \eqref{eq:AbbrevE} with $(z - \psi'X)$ where
\begin{equation*}
  z \equiv y - \psi(\Phi) + \psi' \Phi.
\end{equation*}
The nonlinear version of \eqref{eq:LinearImportance} is
\begin{subequations}
  \begin{align}
    \Sigma_i &= \left( \Sigma_\eta^{-1} + \psi'^T \Sigma_\epsilon^{-1} \psi'
               \right)^{-1} \\
    G_i &= \Sigma_i \psi'^T \Sigma_\epsilon^{-1} \\ \nonumber
    \mu_i &= \Phi + G_i \left(z - \psi' \Phi) \right) \\ \nonumber
             &= \Phi + G_i \left(y - \psi(\Phi) ) \right) \\
             &= \Phi(x[t]) + G_i \left(y[t+1] - \psi(\Phi(x[t]))
               \right)
  \end{align}
\end{subequations}

The code in particle.py uses the above formulas and parameters in
optimize.py.

\begin{tabular}[t]{l|l|r}
  code&comment&log likelihood \\ \hline
  ekf.py & & -6422.0 \\
  particle.py & filtered data a little rough. 18 minutes &
                                                               -6762.4 \\
  particle.py & $\Sigma_\eta /= 100$, filtered data is smooth &
                                                               -12912.5 \\
\end{tabular}

\section{Discrete Observations}
\label{sec:DiscreteObservations}

\section{Optimization}
\label{sec:Optimization}

Found that optimizing many parameters for particle filters yielded
unsatisfactory results.


\section{To Do}
\label{sec:ToDo}

\begin{enumerate}
\item Automate parameter optimization and document it here
\item Write code for particle filter with discrete observations and document
\item Optimize parameters for particle filter
\item Make plot for Introduction
\end{enumerate}
Worked on pymp.  Got it installed and running.  I changed a simple
intialization loop in particle.py to run with pymp and the value of
the log likelihood changed from -17.42 to -14.96.  Then I quit the
effort.
\begin{verbatim}
 5257  git clone https://github.com/classner/pymp.git
 5258  cd pymp/
 5264  python setup.py install --prefix=./
 5281  export PYTHONPATH=/mnt/precious/home/andy_nix/projects/dshmm:/mnt/precious/home/andy_nix/projects/proj_hmm/src:/mnt/precious/home/andy_nix/projects/dshmm:/mnt/precious/home/andy_nix/projects/dshmm/pymp:

Without pymp.  Commit.
[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ make
time python particle.py --n_times 50 powell250.parameters test_particle
log_likelihood=-74.8157538232742

real	0m31.962s
user	1m19.362s
sys	0m0.233s
[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ rm test_particle ; make
time python particle.py --n_times 175 powell2876.parameters test_particle
log_likelihood=-261.40873672698683

real	1m17.545s
user	3m44.015s
sys	0m0.324s

[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ rm test_particle ; make
time python particle.py --n_times 175 powell250.parameters test_particle
log_likelihood=-257.72636060585575

real	1m20.901s
user	3m42.181s
sys	0m0.295s

[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ rm test_particle ; make
time python particle.py --n_times 2876 powell250.parameters test_particle
log_likelihood=-3934.546695234746

real	17m48.662s
user	53m4.767s
sys	0m2.667s

[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ rm test_particle ; make
time python particle.py --n_times 2876 powell2876.parameters test_particle
log_likelihood=-4197.4616110514735

real	17m47.318s
user	53m2.265s
sys	0m2.109s

[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ make BFGS500.parameters 
python optimize_particle.py --length 175 --n_particles 500 --method BFGS powell250.parameters BFGS500.parameters
objective_function = -237.76511221023844

...

parameters_max:
s 8.591062805853925
r 30.911709605175442
b 2.530757772943027
x_initial_0 12.642124632490887
x_initial_1 14.229049995117013
x_initial_2 33.47735576003487
t_ratio 1.0411872486150031
x_ratio 0.7374402784182058
offset 15.071726610324543
state_noise 0.6331351560473886
observation_noise 0.5274712556732416

f_max=-237.31615262807324
success=False
message=Desired error not necessarily achieved due to precision loss.
iterations=1

--------------------------------------------------------------------
[nix-shell:~/projects/dshmm/hmmds/applications/laser]$ time make powell500.parameters 
python optimize_particle.py --length 175 --n_particles 500 --method Powell powell250.parameters powell500.parameters
objective_function = -237.76511221023844

...

parameters_max:
s 8.625160204276375
r 34.91170961478804
b 2.727698133086979
x_initial_0 14.601842957802134
x_initial_1 14.626852632948264
x_initial_2 31.09370692292357
t_ratio 1.0706121819875836
x_ratio 0.6139283863855538
offset 14.928038113748512
state_noise 2.9725619573624966
observation_noise -0.165500717090822

f_max=-209.31257621043827
success=True
message=Optimization terminated successfully.
iterations=2

real	690m15.505s
user	2063m41.648s
sys	1m19.411s

Optimize only state_noise and observation_noise
time make powell500.parameters 
python optimize_particle.py --length 175 --n_particles 500 --method Powell powell250.parameters powell500.parameters
objective_function = -237.76511221023844

...
objective_function = -44.96798951043301
...



parameters_max:
state_noise -0.26316913009998016
observation_noise -0.09638650796359936

f_max=-56.21171164890743
success=True
message=Optimization terminated successfully.
iterations=3

real	209m28.244s
user	626m10.201s
sys	0m24.570s

\end{verbatim}
\end{document}
